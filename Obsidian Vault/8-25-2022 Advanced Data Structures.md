* The large number generated by hash functions are typically converted into hash table slots by using (hash mod m) where m is the number of slots in the hash
* Hash table DoS attacks can be answered by…
	* Collision resistant hashes from cryptography (these try to make it difficult for attackers to generate collisions)
		* These use message digests which are essentially just hashes.
		* For hash tables, people are typically trying to balance some security features of cryptographic hashes and performance.
			* A common one is a SIP hash.
	* Universal hashing
		* You randomly pick from a list of hash functions every time you create a hash table
		* A hash table meets the requirement for universal hashing if the probability of a collision between two arbitrary pairs for any randomly chosen function is less than $\frac{1}{m}$. It means that the hash table simply has to be at least as good at preventing collisions as randomly selecting slots for each
		* This is distinct from uniform hashing because uniformity doesn't imply uniformity based on details of the key. For example, if the family of hashes was decided to be constant functions for each slot in the hash table, it is theoretically uniform.
		* A family of hash functions which simply choose 10 bits from the 64-bit input wouldn't meet this since there exists a pair, perhaps 11111…1 and 11111…0 that would collide probabilistically.
		* The multiplicative method for creating universal hashing families works like so:
			* Pick a prime number larger than $2^{64}$ (this can be done relatively cheaply)
			* The hash function is then $((a \cdot x + b)\mod p)\mod m$ where $a$ is a salt (random number between (and including) 1 and p-1), $p$ is the prime number, $m$ is the number of slots in the hash table, and $b$ is another random number to prevent 0 from hashing to 0.
				* This is effective because $h_a(x) = h_a(y)$ is true when $|(ax\mod p) - (ay\mod p)|$ is a multiple of $m$ up to the floor of P/m, and there will only be one value for $a$ which achieves each multiple. Since there are roughly P/m choices, $\frac{P}{m}\cdot\frac{1}{p} = \frac{1}{m}$ which satisfies the requirement for a universal hash family.
		* A “good enough”, but not provable method is to take two good hash functions and make a new hash function $h_1(x) + i \cdot h_2(x)$.
* The number of expected values per bin in a hashtable of m slots is $n/m$, however, the distribution is not uniform. There is likely to be 
* Load balancing can be done by hashing the job and using mod m where m is the number of processors which can have tasks assigned to.